"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _cssClasses = _interopRequireDefault(require("../cssClasses"));

var _CSSTranslate = _interopRequireDefault(require("../CSSTranslate"));

var _reactEasySwipe = _interopRequireDefault(require("react-easy-swipe"));

var _Thumbs = _interopRequireDefault(require("./Thumbs"));

var customPropTypes = _interopRequireWildcard(require("../customPropTypes"));

require("../main.scss");

require("../carousel.scss");

(function () {
  var enterModule = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).enterModule;
  enterModule && enterModule(module);
})();

var noop = function noop() {};

var defaultStatusFormatter = function defaultStatusFormatter(current, total) {
  return "".concat(current, " of ").concat(total);
};

var Carousel =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2["default"])(Carousel, _Component);

  function Carousel(_props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Carousel);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Carousel).call(this, _props));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "componentDidMount", function () {
      _this.props.remoteLeftArrow(_this.onClickPrev);

      _this.props.remoteRightArrow(_this.onClickNext);

      if (!_this.props.children) {
        return;
      }

      _this.setupCarousel();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setThumbsRef", function (node) {
      _this.thumbsRef = node;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setCarouselWrapperRef", function (node) {
      _this.carouselWrapperRef = node;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setListRef", function (node) {
      _this.listRef = node;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setItemsWrapperRef", function (node) {
      _this.itemsWrapperRef = node;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setItemsRef", function (node, index) {
      if (!_this.itemsRef) {
        _this.itemsRef = [];
      }

      _this.itemsRef[index] = node;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "autoPlay", function () {
      if (!_this.state.autoPlay || _react.Children.count(_this.props.children) <= 1) {
        return;
      }

      clearTimeout(_this.timer);
      _this.timer = setTimeout(function () {
        _this.increment();
      }, _this.props.interval);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "clearAutoPlay", function () {
      if (!_this.state.autoPlay) {
        return;
      }

      clearTimeout(_this.timer);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "resetAutoPlay", function () {
      _this.clearAutoPlay();

      _this.autoPlay();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "stopOnHover", function () {
      _this.setState({
        isMouseEntered: true
      });

      _this.clearAutoPlay();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "startOnLeave", function () {
      _this.setState({
        isMouseEntered: false
      });

      _this.autoPlay();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "navigateWithKeyboard", function (e) {
      var axis = _this.props.axis;
      var isHorizontal = axis === "horizontal";
      var keyNames = {
        ArrowUp: 38,
        ArrowRight: 39,
        ArrowDown: 40,
        ArrowLeft: 37
      };
      var nextKey = isHorizontal ? keyNames.ArrowRight : keyNames.ArrowDown;
      var prevKey = isHorizontal ? keyNames.ArrowLeft : keyNames.ArrowUp;

      if (nextKey === e.keyCode) {
        _this.increment();
      } else if (prevKey === e.keyCode) {
        _this.decrement();
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "updateSizes", function () {
      if (!_this.state.initialized) {
        return;
      }

      var isHorizontal = _this.props.axis === "horizontal";
      var firstItem = _this.itemsRef[0];
      var itemSize = isHorizontal ? firstItem.clientWidth : firstItem.clientHeight;

      _this.setState(function (_state, props) {
        return {
          itemSize: itemSize,
          wrapperSize: isHorizontal ? itemSize * _react.Children.count(props.children) : itemSize
        };
      });

      if (_this.thumbsRef) {
        _this.thumbsRef.updateSizes();
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setMountState", function () {
      _this.setState({
        hasMount: true
      });

      _this.updateSizes();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleClickItem", function (index, item) {
      if (_react.Children.count(_this.props.children) == 0) {
        return;
      }

      if (_this.state.cancelClick) {
        _this.setState({
          cancelClick: false
        });

        return;
      }

      _this.props.onClickItem(index, item);

      if (index !== _this.state.selectedItem) {
        _this.setState({
          selectedItem: index
        });
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleOnChange", function (index, item) {
      if (_react.Children.count(_this.props.children) <= 1) {
        return;
      }

      _this.props.onChange(index, item);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleClickThumb", function (index, item) {
      _this.props.onClickThumb(index, item);

      _this.selectItem({
        selectedItem: index
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onSwipeStart", function () {
      _this.setState({
        swiping: true
      });

      _this.clearAutoPlay();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onSwipeEnd", function () {
      _this.setState({
        swiping: false
      });

      _this.autoPlay();
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onSwipeMove", function (delta) {
      var isHorizontal = _this.props.axis === "horizontal";

      var childrenLength = _react.Children.count(_this.props.children);

      var initialBoundry = 0;

      var currentPosition = _this.getPosition(_this.state.selectedItem);

      var finalBoundry = _this.props.infiniteLoop ? _this.getPosition(childrenLength - 1) - 100 : _this.getPosition(childrenLength - 1);
      var axisDelta = isHorizontal ? delta.x : delta.y;
      var handledDelta = axisDelta; // prevent user from swiping left out of boundaries

      if (currentPosition === initialBoundry && axisDelta > 0) {
        handledDelta = 0;
      } // prevent user from swiping right out of boundaries


      if (currentPosition === finalBoundry && axisDelta < 0) {
        handledDelta = 0;
      }

      var position = currentPosition + 100 / (_this.state.itemSize / handledDelta);

      if (_this.props.infiniteLoop) {
        // When allowing infinite loop, if we slide left from position 0 we reveal the cloned last slide that appears before it
        // if we slide even further we need to jump to other side so it can continue - and vice versa for the last slide
        if (_this.state.selectedItem === 0 && position > -100) {
          position -= childrenLength * 100;
        } else if (_this.state.selectedItem === childrenLength - 1 && position < -childrenLength * 100) {
          position += childrenLength * 100;
        }
      }

      position += "%";

      _this.setPosition(position); // allows scroll if the swipe was within the tolerance


      var hasMoved = Math.abs(axisDelta) > _this.props.swipeScrollTolerance;

      if (hasMoved && !_this.state.cancelClick) {
        _this.setState({
          cancelClick: true
        });
      }

      return hasMoved;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setPosition", function (position, forceReflow) {
      var list = _reactDom["default"].findDOMNode(_this.listRef);

      ["WebkitTransform", "MozTransform", "MsTransform", "OTransform", "transform", "msTransform"].forEach(function (prop) {
        list.style[prop] = (0, _CSSTranslate["default"])(position, _this.props.axis);
      });

      if (forceReflow) {
        list.offsetLeft;
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "resetPosition", function () {
      var currentPosition = _this.getPosition(_this.state.selectedItem) + "%";

      _this.setPosition(currentPosition);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "decrement", function () {
      var positions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var fromSwipe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _this.moveTo(_this.state.selectedItem - (typeof positions === "number" ? positions : 1), fromSwipe);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "increment", function () {
      var positions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var fromSwipe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _this.moveTo(_this.state.selectedItem + (typeof positions === "number" ? positions : 1), fromSwipe);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "moveTo", function (position, fromSwipe) {
      var lastPosition = _react.Children.count(_this.props.children) - 1;
      var needClonedSlide = _this.props.infiniteLoop && !fromSwipe && (position < 0 || position > lastPosition);
      var oldPosition = position;

      if (position < 0) {
        position = _this.props.infiniteLoop ? lastPosition : 0;
      }

      if (position > lastPosition) {
        position = _this.props.infiniteLoop ? 0 : lastPosition;
      }

      if (needClonedSlide) {
        // set swiping true would disable transition time, then we set slider to cloned position and force a reflow
        // this is only needed for non-swiping situation
        _this.setState({
          swiping: true
        }, function () {
          if (oldPosition < 0) {
            if (_this.props.centerMode && _this.props.axis === "horizontal") {
              _this.setPosition("-".concat((lastPosition + 2) * _this.props.centerSlidePercentage - (100 - _this.props.centerSlidePercentage) / 2, "%"), true);
            } else {
              _this.setPosition("-".concat((lastPosition + 2) * 100, "%"), true);
            }
          } else if (oldPosition > lastPosition) {
            _this.setPosition(0, true);
          }

          _this.selectItem({
            selectedItem: position,
            swiping: false
          });
        });
      } else {
        _this.selectItem({
          // if it's not a slider, we don't need to set position here
          selectedItem: position
        });
      } // don't reset auto play when stop on hover is enabled, doing so will trigger a call to auto play more than once
      // and will result in the interval function not being cleared correctly.


      if (_this.state.autoPlay && _this.state.isMouseEntered === false) {
        _this.resetAutoPlay();
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onClickNext", function () {
      _this.increment(1, false);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onClickPrev", function () {
      _this.decrement(1, false);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onSwipeForward", function () {
      _this.increment(1, true);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onSwipeBackwards", function () {
      _this.decrement(1, true);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "changeItem", function (e) {
      if (!e.key || e.key === "Enter") {
        var newIndex = e.target.value;

        _this.selectItem({
          selectedItem: newIndex
        });
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "selectItem", function (state, cb) {
      _this.setState(state, cb);

      _this.handleOnChange(state.selectedItem, _react.Children.toArray(_this.props.children)[state.selectedItem]);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getInitialImage", function () {
      var selectedItem = _this.props.selectedItem;
      var item = _this.itemsRef && _this.itemsRef[selectedItem];
      var images = item && item.getElementsByTagName("img");
      return images && images[selectedItem];
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getVariableImageHeight", function (position) {
      var item = _this.itemsRef && _this.itemsRef[position];
      var images = item && item.getElementsByTagName("img");

      if (_this.state.hasMount && images.length > 0) {
        var image = images[0];

        if (!image.complete) {
          // if the image is still loading, the size won't be available so we trigger a new render after it's done
          var onImageLoad = function onImageLoad() {
            _this.forceUpdate();

            image.removeEventListener("load", onImageLoad);
          };

          image.addEventListener("load", onImageLoad);
        }

        var height = image.clientHeight;
        return height > 0 ? height : null;
      }

      return null;
    });
    _this.state = {
      initialized: false,
      selectedItem: _props.selectedItem,
      hasMount: false,
      isMouseEntered: false,
      autoPlay: _props.autoPlay
    };
    return _this;
  }

  (0, _createClass2["default"])(Carousel, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (nextProps.selectedItem !== this.state.selectedItem) {
        this.updateSizes();
        this.moveTo(nextProps.selectedItem);
      }

      if (nextProps.autoPlay !== this.state.autoPlay) {
        this.setState({
          autoPlay: nextProps.autoPlay
        }, function () {
          if (_this2.state.autoPlay) {
            _this2.setupAutoPlay();
          } else {
            _this2.destroyAutoPlay();
          }
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (!prevProps.children && this.props.children && !this.state.initialized) {
        this.setupCarousel();
      }

      if (prevState.swiping && !this.state.swiping) {
        // We stopped swiping, ensure we are heading to the new/current slide and not stuck
        this.resetPosition();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.destroyCarousel();
    }
  }, {
    key: "setupCarousel",
    value: function setupCarousel() {
      this.bindEvents();

      if (this.state.autoPlay && _react.Children.count(this.props.children) > 1) {
        this.setupAutoPlay();
      }

      this.setState({
        initialized: true
      });
      var initialImage = this.getInitialImage();

      if (initialImage) {
        // if it's a carousel of images, we set the mount state after the first image is loaded
        initialImage.addEventListener("load", this.setMountState);
      } else {
        this.setMountState();
      }
    }
  }, {
    key: "destroyCarousel",
    value: function destroyCarousel() {
      if (this.state.initialized) {
        this.unbindEvents();
        this.destroyAutoPlay();
      }
    }
  }, {
    key: "setupAutoPlay",
    value: function setupAutoPlay() {
      this.autoPlay();
      var carouselWrapper = this.carouselWrapperRef;

      if (this.props.stopOnHover && carouselWrapper) {
        carouselWrapper.addEventListener("mouseenter", this.stopOnHover);
        carouselWrapper.addEventListener("mouseleave", this.startOnLeave);
      }
    }
  }, {
    key: "destroyAutoPlay",
    value: function destroyAutoPlay() {
      this.clearAutoPlay();
      var carouselWrapper = this.carouselWrapperRef;

      if (this.props.stopOnHover && carouselWrapper) {
        carouselWrapper.removeEventListener("mouseenter", this.stopOnHover);
        carouselWrapper.removeEventListener("mouseleave", this.startOnLeave);
      }
    }
  }, {
    key: "bindEvents",
    value: function bindEvents() {
      // as the widths are calculated, we need to resize
      // the carousel when the window is resized
      window.addEventListener("resize", this.updateSizes); // issue #2 - image loading smaller

      window.addEventListener("DOMContentLoaded", this.updateSizes);

      if (this.props.useKeyboardArrows) {
        document.addEventListener("keydown", this.navigateWithKeyboard);
      }
    }
  }, {
    key: "unbindEvents",
    value: function unbindEvents() {
      // removing listeners
      window.removeEventListener("resize", this.updateSizes);
      window.removeEventListener("DOMContentLoaded", this.updateSizes);
      var initialImage = this.getInitialImage();

      if (initialImage) {
        initialImage.removeEventListener("load", this.setMountState);
      }

      if (this.props.useKeyboardArrows) {
        document.removeEventListener("keydown", this.navigateWithKeyboard);
      }
    }
  }, {
    key: "getPosition",
    value: function getPosition(index) {
      if (this.props.infiniteLoop) {
        // index has to be added by 1 because of the first cloned slide
        ++index;
      }

      var childrenLength = _react.Children.count(this.props.children);

      if (this.props.centerMode && this.props.axis === "horizontal") {
        var currentPosition = -index * this.props.centerSlidePercentage;
        var lastPosition = childrenLength - 1;

        if (index && (index !== lastPosition || this.props.infiniteLoop)) {
          currentPosition += (100 - this.props.centerSlidePercentage) / 2;
        } else if (index === lastPosition) {
          currentPosition += 100 - this.props.centerSlidePercentage;
        }

        return currentPosition;
      }

      return -index * 100;
    }
  }, {
    key: "renderItems",
    value: function renderItems(isClone) {
      var _this3 = this;

      return _react.Children.map(this.props.children, function (item, index) {
        var slideProps = {
          ref: function ref(e) {
            return _this3.setItemsRef(e, index);
          },
          key: "itemKey" + index + (isClone ? "clone" : ""),
          className: _cssClasses["default"].ITEM(true, index === _this3.state.selectedItem),
          onClick: _this3.handleClickItem.bind(_this3, index, item)
        };

        if (_this3.props.centerMode && _this3.props.axis === "horizontal") {
          slideProps.style = {
            minWidth: _this3.props.centerSlidePercentage + "%"
          };
        }

        return _react["default"].createElement("li", slideProps, item);
      });
    }
  }, {
    key: "renderControls",
    value: function renderControls() {
      var _this4 = this;

      if (!this.props.showIndicators) {
        return null;
      }

      return _react["default"].createElement("ul", {
        className: "control-dots"
      }, _react.Children.map(this.props.children, function (item, index) {
        return _react["default"].createElement("li", {
          className: _cssClasses["default"].DOT(index === _this4.state.selectedItem),
          onClick: _this4.changeItem,
          onKeyDown: _this4.changeItem,
          value: index,
          key: index,
          role: "button",
          tabIndex: 0
        });
      }));
    }
  }, {
    key: "renderStatus",
    value: function renderStatus() {
      if (!this.props.showStatus) {
        return null;
      }

      return _react["default"].createElement("p", {
        className: "carousel-status"
      }, this.props.statusFormatter(this.state.selectedItem + 1, _react.Children.count(this.props.children)));
    }
  }, {
    key: "renderThumbs",
    value: function renderThumbs() {
      if (!this.props.showThumbs || _react.Children.count(this.props.children) === 0) {
        return null;
      }

      return _react["default"].createElement(_Thumbs["default"], {
        ref: this.setThumbsRef,
        onSelectItem: this.handleClickThumb,
        selectedItem: this.state.selectedItem,
        transitionTime: this.props.transitionTime,
        thumbWidth: this.props.thumbWidth
      }, this.props.children);
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.props.children || _react.Children.count(this.props.children) === 0) {
        return null;
      }

      var isHorizontal = this.props.axis === "horizontal";
      var canShowArrows = this.props.showArrows && _react.Children.count(this.props.children) > 1; // show left arrow?

      var hasPrev = canShowArrows && (this.state.selectedItem > 0 || this.props.infiniteLoop); // show right arrow

      var hasNext = canShowArrows && (this.state.selectedItem < _react.Children.count(this.props.children) - 1 || this.props.infiniteLoop); // obj to hold the transformations and styles

      var itemListStyles = {};
      var currentPosition = this.getPosition(this.state.selectedItem); // if 3d is available, let's take advantage of the performance of transform

      var transformProp = (0, _CSSTranslate["default"])(currentPosition + "%", this.props.axis);
      var transitionTime = this.props.transitionTime + "ms";
      itemListStyles = {
        WebkitTransform: transformProp,
        MozTransform: transformProp,
        MsTransform: transformProp,
        OTransform: transformProp,
        transform: transformProp,
        msTransform: transformProp
      };

      if (!this.state.swiping) {
        itemListStyles = (0, _objectSpread2["default"])({}, itemListStyles, {
          WebkitTransitionDuration: transitionTime,
          MozTransitionDuration: transitionTime,
          MsTransitionDuration: transitionTime,
          OTransitionDuration: transitionTime,
          transitionDuration: transitionTime,
          msTransitionDuration: transitionTime
        });
      }

      var itemsClone = this.renderItems(true);
      var firstClone = itemsClone.shift();
      var lastClone = itemsClone.pop();
      var swiperProps = {
        selectedItem: this.state.selectedItem,
        className: _cssClasses["default"].SLIDER(true, this.state.swiping),
        onSwipeMove: this.onSwipeMove,
        onSwipeStart: this.onSwipeStart,
        onSwipeEnd: this.onSwipeEnd,
        style: itemListStyles,
        tolerance: this.props.swipeScrollTolerance
      };
      var containerStyles = {};

      if (isHorizontal) {
        swiperProps.onSwipeLeft = this.onSwipeForward;
        swiperProps.onSwipeRight = this.onSwipeBackwards;

        if (this.props.dynamicHeight) {
          var itemHeight = this.getVariableImageHeight(this.state.selectedItem);
          swiperProps.style.height = itemHeight || "auto";
          containerStyles.height = itemHeight || "auto";
        }
      } else {
        swiperProps.onSwipeUp = this.props.verticalSwipe === "natural" ? this.onSwipeBackwards : this.onSwipeForward;
        swiperProps.onSwipeDown = this.props.verticalSwipe === "natural" ? this.onSwipeForward : this.onSwipeBackwards;
        swiperProps.style.height = this.state.itemSize;
        containerStyles.height = this.state.itemSize;
      }

      return _react["default"].createElement("div", {
        className: this.props.className,
        ref: this.setCarouselWrapperRef
      }, _react["default"].createElement("div", {
        className: _cssClasses["default"].CAROUSEL(true),
        style: {
          width: this.props.width
        }
      }, _react["default"].createElement("button", {
        type: "button",
        className: _cssClasses["default"].ARROW_PREV(!hasPrev),
        onClick: this.onClickPrev
      }), _react["default"].createElement("div", {
        className: _cssClasses["default"].WRAPPER(true, this.props.axis),
        style: containerStyles,
        ref: this.setItemsWrapperRef
      }, this.props.swipeable ? _react["default"].createElement(_reactEasySwipe["default"], (0, _extends2["default"])({
        tagName: "ul",
        ref: this.setListRef
      }, swiperProps, {
        allowMouseEvents: this.props.emulateTouch
      }), this.props.infiniteLoop && lastClone, this.renderItems(), this.props.infiniteLoop && firstClone) : _react["default"].createElement("ul", {
        className: _cssClasses["default"].SLIDER(true, this.state.swiping),
        ref: this.setListRef,
        style: itemListStyles
      }, this.props.infiniteLoop && lastClone, this.renderItems(), this.props.infiniteLoop && firstClone)), _react["default"].createElement("button", {
        type: "button",
        className: _cssClasses["default"].ARROW_NEXT(!hasNext),
        onClick: this.onClickNext
      }), this.renderControls(), this.renderStatus()), this.renderThumbs());
    }
  }, {
    key: "__reactstandin__regenerateByEval",
    // @ts-ignore
    value: function __reactstandin__regenerateByEval(key, code) {
      // @ts-ignore
      this[key] = eval(code);
    }
  }]);
  return Carousel;
}(_react.Component);

(0, _defineProperty2["default"])(Carousel, "displayName", "Carousel");
(0, _defineProperty2["default"])(Carousel, "propTypes", {
  className: _propTypes["default"].string,
  children: _propTypes["default"].node,
  showArrows: _propTypes["default"].bool,
  showStatus: _propTypes["default"].bool,
  showIndicators: _propTypes["default"].bool,
  infiniteLoop: _propTypes["default"].bool,
  showThumbs: _propTypes["default"].bool,
  thumbWidth: _propTypes["default"].number,
  selectedItem: _propTypes["default"].number,
  onClickItem: _propTypes["default"].func.isRequired,
  onClickThumb: _propTypes["default"].func.isRequired,
  onChange: _propTypes["default"].func.isRequired,
  axis: _propTypes["default"].oneOf(["horizontal", "vertical"]),
  verticalSwipe: _propTypes["default"].oneOf(["natural", "standard"]),
  width: customPropTypes.unit,
  useKeyboardArrows: _propTypes["default"].bool,
  autoPlay: _propTypes["default"].bool,
  stopOnHover: _propTypes["default"].bool,
  interval: _propTypes["default"].number,
  transitionTime: _propTypes["default"].number,
  swipeScrollTolerance: _propTypes["default"].number,
  swipeable: _propTypes["default"].bool,
  dynamicHeight: _propTypes["default"].bool,
  emulateTouch: _propTypes["default"].bool,
  statusFormatter: _propTypes["default"].func.isRequired,
  centerMode: _propTypes["default"].bool,
  centerSlidePercentage: _propTypes["default"].number
});
(0, _defineProperty2["default"])(Carousel, "defaultProps", {
  showIndicators: true,
  showArrows: true,
  showStatus: true,
  showThumbs: true,
  infiniteLoop: false,
  selectedItem: 0,
  axis: "horizontal",
  verticalSwipe: "standard",
  width: "100%",
  useKeyboardArrows: false,
  autoPlay: false,
  stopOnHover: true,
  interval: 3000,
  transitionTime: 350,
  swipeScrollTolerance: 5,
  swipeable: true,
  dynamicHeight: false,
  emulateTouch: false,
  onClickItem: noop,
  onClickThumb: noop,
  onChange: noop,
  statusFormatter: defaultStatusFormatter,
  centerMode: false,
  centerSlidePercentage: 80
});
var _default = Carousel;
var _default2 = _default;
exports["default"] = _default2;
;

(function () {
  var reactHotLoader = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).default;

  if (!reactHotLoader) {
    return;
  }

  reactHotLoader.register(noop, "noop", "/var/www/html/carousel/src/components/Carousel.js");
  reactHotLoader.register(defaultStatusFormatter, "defaultStatusFormatter", "/var/www/html/carousel/src/components/Carousel.js");
  reactHotLoader.register(Carousel, "Carousel", "/var/www/html/carousel/src/components/Carousel.js");
  reactHotLoader.register(_default, "default", "/var/www/html/carousel/src/components/Carousel.js");
})();

;

(function () {
  var leaveModule = (typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal : require('react-hot-loader')).leaveModule;
  leaveModule && leaveModule(module);
})();